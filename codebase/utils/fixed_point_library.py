""" Gal from QM sent us this module to determine precisely the sweep points generated by qm.qua.for_(), instead of us relying on numpy.arange() """

import struct
from qm.qua import fixed

"""
This library was originally developed internally at Quantum Machines. The purpose of this
library is to deal with converting python's int, bool, and floating point to
and from the custom FixedPoint format. The docstrings below are my own. 
This library is in use in opx_library - in order to extract the for_
and for_each_ loop variables, the literals must be converted to FixedPoint 
to ensure no weird boundary issues with differences in precision.
"""


class FixedPoint:
    """
    This is a base class that handles the creation of FixedPoint precision
    objects given an int or float at initialization.
    """

    def __init__(self, value, frac, from_uint=False):
        """
        Initializes a FixedPoint object with a given value and dec expansion.
        frac is the number of powers of 2 to the right of the decimal.
        It should be 28 for type fixed (4.28 format) and 0 for
        integer.
        """
        self._frac = frac
        self._value = None
        self.set(value, from_uint)

    def int_value(self):
        """Returns the uint representation of a FixedPoint object"""
        return self._value

    def get_value(self):
        """
        Converts FixedPoint uint value to a signed int and shifts
        by the frac number of bits. Returns a float always.
        """
        return FixedPoint.uint_to_int(self._value) / (2 ** self._frac)

    def __str__(self):
        """String represetation of FixedPoint object (float value)."""
        return str(self.get_value())

    def set(self, value, from_uint=False):
        """
        This sets the _value property of the FixedPoint object. It is
        the unsigned integer representation. If it comes from an non-uint
        value, the integer is first shifted right by frac bits. Then it is
        possibly unwrapped from negative to positive.
        """
        if isinstance(value, FixedPoint):
            self._value = value.int_value()
        if type(value) is int or type(value) is float:
            if from_uint:
                self._value = int(value)
            else:
                self._value = FixedPoint.int_to_uint(
                    int(round(value * (2 ** self._frac)))
                )

    @staticmethod
    def int_to_uint(x):
        """
        Converts a signed int to unsigned. This handles unwrapping negative
        values back around to positive.
        "Q" = unsigned long long 8 byte
        "q" = signed long long 8 byte
        """
        if x >= 0:
            return x
        return struct.unpack_from("Q", struct.pack("q", x))[0]

    @staticmethod
    def uint_to_int(x):
        """
        Converts an unsigned int to signed ing. This splits the uint range
        in half, and wraps the greater half to negative.
        #I = unsigned int 4 byte
        #i = signed int 4 byte
        """
        return struct.unpack_from("i", struct.pack("I", x % 2 ** 32))[0]

    @staticmethod
    def fix(x, shift=0):
        """Bit shifts to right by shift, then returns remainder after dividing
        by 2**32. Returns x if x > 0."""
        return FixedPoint.int_to_uint(x >> shift) % 2 ** 32

    def get_other(self, other):
        """
        This is a helper for binary mathematical operations. It determines
        the type of the other element in the operation. If not FixedPoint,
        it converts the other element to a FixedPoint format.
        """
        if isinstance(other, FixedPoint):
            return other
        if type(other) is int or type(other) is float:
            return FixedPoint(other, self._frac)

    def __add__(self, other):
        other = self.get_other(other)
        return FixedPoint(
            self.fix(self.int_value() + other.int_value()), self._frac, True
        )

    def __sub__(self, other):
        other = self.get_other(other)
        res = FixedPoint.int_to_uint(self.int_value() - other.int_value())
        return FixedPoint(self.fix(res), self._frac, True)

    def __mul__(self, other):
        other_int = FixedPoint.uint_to_int(self.get_other(other).int_value())
        my_int = FixedPoint.uint_to_int(self.int_value())
        res = FixedPoint.int_to_uint(my_int * other_int)
        return FixedPoint(self.fix(res, self._frac), self._frac, True)

    def __gt__(self, other):
        other = self.get_other(other)
        return self.get_value() > other.get_value()

    def __ge__(self, other):
        other = self.get_other(other)
        return self.get_value() >= other.get_value()

    def __le__(self, other):
        other = self.get_other(other)
        return self.get_value() <= other.get_value()

    def __lt__(self, other):
        other = self.get_other(other)
        return self.get_value() < other.get_value()

    def __eq__(self, other):
        other = self.get_other(other)
        return self.get_value() == other.get_value()


class Fixed(FixedPoint):
    def __init__(self, value):
        super().__init__(value, 28)


class Int(FixedPoint):
    def __init__(self, value):
        super().__init__(value, 0)


def declare_py(t, value):
    if type(value) is list:
        if t == int:
            return [Int(i) for i in value]
        elif t == fixed:
            return [Fixed(i) for i in value]
        elif t == bool:
            return value
    else:
        if t == int:
            return Int(value)
        elif t == fixed:
            return Fixed(value)
        elif t == bool:
            return value    
